[1mdiff --cc Assets/Scripts/DragDropBehaviourScript.cs[m
[1mindex 1e6b995,565a581..0000000[m
[1m--- a/Assets/Scripts/DragDropBehaviourScript.cs[m
[1m+++ b/Assets/Scripts/DragDropBehaviourScript.cs[m
[36m@@@ -8,15 -8,11 +8,20 @@@[m [mpublic class DragDropBehaviourScript : [m
      private Vector3 startingPosition;[m
      private List<GameObject> combining = new List<GameObject>();[m
      public GameObject combinationZone;[m
[32m++<<<<<<< Updated upstream[m
[32m +    private float sensitivity = 1.0f;[m
[32m +    private GameObject grid;[m
[32m++=======[m
[32m+     private readonly float sensitivity = 2.0f;[m
[32m+     private bool isIngredient = false;[m
[32m++>>>>>>> Stashed changes[m
  [m
[31m -    // Update is called once per frame[m
[31m -    void Update()[m
[32m +    void Start()[m
[32m +    {[m
[32m +        grid = GameObject.Find("PlaceholderGrid");[m
[32m +    }[m
[32m +        // Update is called once per frame[m
[32m +        void Update()[m
      {[m
  [m
          // If left mouse button is clicked[m
[36m@@@ -54,65 -55,62 +64,119 @@@[m
          }[m
      }[m
  [m
[32m+     // Drags selected object if something is at mouse position[m
[32m+     void DragObject()[m
[32m+     {[m
[32m+         // Set transparency of object to 70%[m
[32m+         selectedObject.GetComponent<SpriteRenderer>().color = new Color(1f, 1f, 1f, .7f);[m
[32m+ [m
[32m+         // Change the position of the selected object based on the position of the mouse (accounting for offset)[m
[32m+         selectedObject.transform.position = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, Camera.main.nearClipPlane + 10.0f));[m
[32m+     }[m
[32m+     [m
[32m+     // Method overloading[m
      void DropObject()[m
      {[m
[32m+         DropObject(null);[m
[32m+     }[m
  [m
[32m++<<<<<<< Updated upstream[m
[32m +        // Clones the selected object at its starting position once dropped[m
[32m +        /* Ideally this clone should be happening at the start of the dragging to[m
[32m +         * make more sense (player isn't always seemingly dragging out the last item),[m
[32m +         * but having the code there right now allows players to drag clones out from[m
[32m +         * the combination area after the original object has already been placed down.[m
[32m +         * Will need to be fixed later on but should still work for the prototype logic.[m
[32m +         */[m
[32m +        GameObject clone = Instantiate(selectedObject);[m
[32m +        GridCreate gridScript = grid.GetComponent<GridCreate>();[m
[32m +        Vector3 nearestPos = selectedObject.transform.position;[m
[32m +        float nearestDistance = Vector3.Distance(grid.transform.position, selectedObject.transform.position);[m
[32m +        List<Vector3> gridPositions;[m
[32m +        gridPositions = gridScript.getPositions(); //grabs list of grid positions from the GridCreate script[m
[32m +        clone.transform.position = startingPosition;[m
[32m +[m
[32m +        Debug.Log(nearestDistance);[m
[32m +[m
[32m +        foreach (Vector3 p in gridPositions)[m
[32m +        {[m
[32m +            float newDistance = Vector3.Distance(p, selectedObject.transform.position);[m
[32m +            if (newDistance < nearestDistance)[m
[32m +            {[m
[32m +                nearestDistance = newDistance;[m
[32m +                nearestPos = p;[m
[32m +            }[m
[32m +        }[m
[32m +[m
[32m +[m
[32m +        Debug.Log(nearestDistance);[m
[32m +        Debug.Log(nearestPos);[m
[32m +[m
[32m +        // Checks if the selected object is close enough or on the object that's been designated as the combination area[m
[32m +        // Will only accept new object placements if the list of things to be combined is not yet at 2 (assuming 2 objects will be the limit, subject to chenge)[m
[32m +        if (Vector3.Distance(combinationZone.transform.position, selectedObject.transform.position) < sensitivity && combining.Count < 2)[m
[32m++=======[m
[32m+     // Drops object that was being dragged by mouse[m
[32m+     void DropObject(List<GameObject> positions)[m
[32m+     {[m
[32m+         // Resets object transparency[m
[32m+         selectedObject.GetComponent<SpriteRenderer>().color = new Color(1f, 1f, 1f, 1f);[m
[32m+ [m
[32m+         if (isIngredient)[m
          {[m
[31m-             // Snaps object into the same position[m
[31m-             selectedObject.transform.position = new Vector3(combinationZone.transform.position.x, combinationZone.transform.position.y, combinationZone.transform.position.z - 0.1f);[m
[32m+             // Checks if the selected object is close enough or on the object that's been designated as the combination area[m
[32m+             // Will only accept new object placements if the list of things to be combined is not yet at 2 (assuming 2 objects will be the limit, subject to chenge)[m
[32m+             if (Vector3.Distance(combinationZone.transform.position, selectedObject.transform.position) < sensitivity && combining.Count < 2)[m
[32m+             {[m
[32m+                 // Snaps object into the same position[m
[32m+                 selectedObject.transform.position = combinationZone.transform.position;[m
  [m
[32m+                 // Adds selected object to list[m
[32m+                 combining.Add(selectedObject);[m
[32m+             }[m
[32m+             else[m
[32m+             {[m
[32m+                 // Destroy the object selected if there are already 2 items in combination area or if not placed close enough[m
[32m+ [m
[32m+                 /* Should be updated by combination logic so that both items[m
[32m+                  * will be destroyed either way once there are two items here[m
[32m+                  * regardless of if they are allowed to combine or not.[m
[32m+                  * Might need a new function, probably also an elif for when[m
[32m+                  * combining.Count == 2.[m
[32m+                  */[m
[32m+                 GameObject clone = Instantiate(selectedObject);[m
[32m+                 clone.transform.position = startingPosition;[m
[32m+                 Destroy(selectedObject);[m
[32m+             }[m
[32m+         } else if (positions != null)[m
[32m++>>>>>>> Stashed changes[m
[32m++        {[m
[32m++[m
[32m++<<<<<<< Updated upstream[m
[32m +            // Adds selected object to list[m
[32m +            combining.Add(selectedObject);[m
[32m +        } else if (nearestDistance < sensitivity) {[m
[32m +            // Snaps object into the same position[m
[32m +            selectedObject.transform.position = nearestPos;[m
[32m +        }[m
[32m +        else[m
          {[m
[32m +            // Destroy the object selected if there are already 2 items in combination area or if not placed close enough[m
  [m
[32m +            /* Should be updated by combination logic so that both items[m
[32m +             * will be destroyed either way once there are two items here[m
[32m +             * regardless of if they are allowed to combine or not.[m
[32m +             * Might need a new function, probably also an elif for when[m
[32m +             * combining.Count == 2.[m
[32m +             */[m
[32m +            Destroy(selectedObject);[m
[32m++=======[m
[32m+         } else[m
[32m+         {[m
[32m+             throw Exception;[m
[32m++>>>>>>> Stashed changes[m
          }[m
[32m+         [m
  [m
          selectedObject = null;[m
      }[m
